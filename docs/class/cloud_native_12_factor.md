## **Cloud Native 12 Factor(30)**

Twelve-Factor App 방법론은 Cloud Native Application 구축 시 지켜야 할 12가지 Best Practice를 기술한다.

1. **코드베이스(CodeBase)**: 애플리케이션의 1개의 코드베이스(Git)를 통해 관리되어야 하며, 동일한 코드로 운영/개발에 배포하여야 한다.
    - 애플리케이션은 1개의 코드 베이스를 가진다.
    - 애플리케이션은 1개의 코드베이스를 통해 운영/개발용으로 배포한다.
    - 코드베이스 항목은 이어지는 타 항목을 준수하기 위해 기본적으로 지켜야할 항목이다.
    - 코드베이스 항목은 SVN, Git과 같은 코드 관리 시스템 사용으로 준수 할수 있다.
    - 여러 애플리케이션이 동일한 코드를 공유해야 한다면 이를 라이브러리화 시키고, 해당 라이브러리를 종속성으로 관리합니다.
2. **종속성(Dependencies)**: 애플리케이션의 모든 종속성을 명시적으로 선언하여 사용한다. 애플리케이션이 필요로 하는 라이브러리를 종속성 선언 파일(depedency manifesto file)에 명시적으로 선언하여 사용한다. (예: Gradle의 경우 gradle.build) 애플리케이션은 상황에 따라 배포될 수 있는 곳이 바뀔 수 있기 때문에 다양한 환경에서도 정상 동작을 보장해야 한다.
    - 종속성 항목은 Gradle을 사용하여 준수한다.
    - 필요한 모든 라이브러리와 버전을 리스트 업하고 배포할 때 빌드 명령어를 실행하여 빌드한다.
3. **설정(Config)**: 모든 설정 정보는 코드로부터 분리된 공간에 저장되어야 하고, 런타임에서 코드에 의해 읽혀야한다. 동일한 코드를 여러환경(Dev/Stage/Production)에 배포하기 때문에 이를 위해서 환경마다 달리 사용되어야 하는 정보를 분리한다.
    - 데이터베이스나 다른 백업 서비스를 처리하는 리소스
    - 외부 리소스의 인증 정보
    - 각 배포마다 달라지는 값(etc: canonical hostname)
    - 설정 정보를 저장하면 안되는 곳
        - 코드(code)
        - 설정 파일(properties file)
        - 빌드 스크립트(build file)
        - 앱 서버(app server)
4. **백엔드 서비스(Backing services)**: 백엔드 서비스를 연결된 리소스로 취급한다. Cloud Native Application의 리소스는 자유롭게 배포에 연결되거나 분리할 수 있고, 코드 수정 없이 전환이 가능해야한다.
    - 백엔드 서비스: 네트워크를 통해 이용하는 모든 서비스
        - 데이터 저장소
        - 메시지 큐잉 시스템
        - SMTP 서비스
        - 캐시 시스템 등
    - 핵심은 로컬 서비스와 서드파티 서비스를 별도로 생각하지 않고 느슨하게 연결된 리소스로 다룬다는 점
        - 애플리케이션 입장에서는 양 쪽 모드 연결된 리소스
        - 설정에 백엔드 서비스의 URL이나 Locator를 저장하고 코드에서는 설정을 읽어서 사용
5. **빌드(Build), 릴리스(Release), 실행(Run)**: 코드 베이스는 ‘빌드 > 릴리스 > 실행의 단계’를 거처 배포로 변환되어야 하고, 각 단계는 엄격하게 분리되어야 한다.
    - 빌드: 코드 저장소를 빌드라는 실행 가능한 번들로 변환 시킨다.
    - 릴리스: 빌드 단계에서 만들어진 빌드와 배포의 현재 설정을 결합한다.
    - 실행: 선택된 릴리즈에 대한 애플리케이션 프로세스의 집합을 시작해 애플리케이션을 실행 환경에서 돌아가도록 한다.
6. **프로세스(Process)**: 실행 환경에서 앱은 하나 이상의 프로세스로 실행되며, 각 프로세스는 stateless로 아무것도 공유하지 않아야 한다.
    - Cloud Native Application는 여러 개의 인스턴스로 배포될 수 있다.
    - 각 인스턴스는 메모리 파일 등을 공유할 수 없으며, 인스턴스가 재실행 될 때 local file, session과 같은 상태 정보는 모두 초기화된다.
        - 유지될 필요가 있는 모든 데이터는 데이터베이스 같은 안정된 백엔드 서비스에 저장되어야 한다.
    - 메모리/파일을 사용할 경우 단일 트랜잭션 내에서 읽고, 쓰고 등의 모든 작업을 처리한다.
    - 세션 상태 데이터의 경우 Memcached 또는 Redis와 같은 데이터 저장소에 저장한다.
7. **포트 바인딩(Port Binding)**: 배포된 Cloud Native Application을 타 애플리케이션에서 접근할 수 있도록 포트 바인딩을 통해 서비스를 공개한다. 앱도 백엔드 서비스처럼 URL을 제공하고, 라우팅 레이어가 외부에 공개된 호스트 명의로 들어온 요청을 포트에 바인딩 된 웹 프로세스에 전달한다.
    - Cloud Native Application은 완전히 독립적이며 실행환경에 대한 런타임 인젝션에 의존하지 않아야 한다.
    - Cloud Native Application은 포트를 바인딩하여 HTTP 서비스로 공개되며 그 포트로 들어오는 요청을 기다려야 한다.
8. **동시성(Concurrency)**: Cloud Native Application은 수평으로 확장할 수 있어야 하고, 아무것도 공유하지 않아야 한다.
    - Cloud Native Applicaion은 동시성을 높이기 위해 절대 데몬화해서는 안되며 PID 파일을 작성해서는 안된다.
    - Cloud Platform의 분산 프로세스 매니저 같은 툴에 의거하여 재시작과 종료를 처리해야 한다.
9. **폐기 가능성(Disposability)**: 프로세스는 SIGTERM 신호를 받았을 때 우아한 종료(graceful shutdown)이 가능해야 한다.
    - Cloud Native Application는 요청에 의해 Scale in/out이 빈번하게 일어나기 때문에 폐기 가능성을를 준수함으로써 운영의 안정성을 확보 할 수 있다. 또한, 프로세스는 하드웨어 에러에 의한 갑작스런 종료가 있을때도 견고하게 유지될 수 있어야 한다.
10. **개발(Development)/검증(Stage)/프로덕션(Production) 환경 일치**: 개발, 검증, 프로덕션 환경을 최대한 비슷하게 유지해야 한다. 개발환경과 운영환경은 매번 큰 차이가 있고, 이 때문에 문제를 미리 찾지 못하는 경우가 생긴다. 개발환경과 운영환경의 차이를 작게 유지하여 지속적인 배포가 가능하도록 설계 해야 한다.
    - 시간의 차이를 최소화: 개발자가 작성한 코드는 몇 시간 또는 몇 분 후에 배포되어야 한다.
    - 담당자의 차이를 최소화: 코드를 작성한 개발자들이 배포와 프로덕션 환경에서의 모니터링에 깊게 관여해야 한다.
    - 툴의 차이를 최소화: 개발과 운영 환경을 최대한 비슷하게 유지해야 한다.
11. **로그(Log)**: 로그를 이벤트 스트림으로 취급하여 로그를 로컬에 저장하지 말아야 한다. Cloud Native Application은 언제든지 인스턴스가 생성/삭제될 수 있습니다. 이때 로컬에 저장된 로그는 초기화되기 때문에 로그는 스트림으로 취급하여 별도의 저장소에 보관해야 한다.
    1. 스트림을 버퍼링 없이 stdout, stderr로 출력해야 한다.
    2. 별도의 로그 저장소를 사용해 분석할 수 있도록 해야 한다.
12. **관리자 프로세스(Admin Process)**: admin/maintenance 작업을 일회성 프로세스로 실행해야 한다.
    1. 일회성 프로세스: 데이터 마이그레이션, 일회성 스크립트 실행
    2. 관리/유지보수 작업은 release와 함께 실행한다.
    3. release와 동일한 환경에서 테스트 할 수 있도록 지원하고, 같은 코드 베이스와 config를 사용해야한다.
    4. admin 코드는 동기화 문제를 피하기 위해 애플리케이션 코드와 함께 배포해야 한다.

### Deploy 실습 - 환경변수 주입 (30)
